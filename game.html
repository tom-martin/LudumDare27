<html>
  <head>
    <title>Ludum Dare 27</title>
    <script type='text/javascript'>


// A cross-browser requestAnimationFrame
// See https://hacks.mozilla.org/2011/08/animating-with-javascript-from-setinterval-to-requestanimationframe/
var requestAnimFrame = (function(){
  return window.requestAnimationFrame       ||
    window.webkitRequestAnimationFrame ||
    window.mozRequestAnimationFrame    ||
    window.oRequestAnimationFrame      ||
    window.msRequestAnimationFrame     ||
    function(callback){
        window.setTimeout(callback, 1000 / 60);
    };
})();

</script>
<style>

</style>
  </head>
  <body>
    <canvas id="gameCanvas" width="1280" height="600">Fallback content, in case the browser does not support Canvas.</canvas>
    <p id="fps">0<p>
    <script src="player.js"></script>
    <script src="platform.js"></script>
    <script src="collision.js"></script>
    <script src="battery.js"></script>
    <script src="door.js"></script>
    <script src="spike.js"></script>
    <script src="levels.js"></script>
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
    <script>
$(function() {
  var $document = $(document);
  var keys = {
    left: false,
    right: false,
    jump: false
  };

  var zoom = 0.5;

  $document.keydown(function(e) {
    if(e.keyCode==37) {
      keys['left'] = true;
    } else if(e.keyCode==39) {
      keys['right'] = true;
    } else if(e.keyCode==32) {
      keys['jump'] = true;
    }
  });

  $document.keyup(function(e) {
    if(e.keyCode==37) {
      keys['left'] = false;
    } else if(e.keyCode==39) {
      keys['right'] = false;
    } else if(e.keyCode==32) {
      keys['jump'] = false;
    }
  });

  var $canvas = $("canvas");
  canvas = $("canvas").get(0);
  context = canvas.getContext('2d');

  var $fps = $("#fps");
  var fps = 0;

  var backImage = new Image();
  backImage.src = "images/back.png";

  var playerImage = new Image();
  playerImage.onload = function () {
    render();
  };
  playerImage.src = "images/robot.png";

  var jumpImage = new Image();
  jumpImage.src = "images/robotjump.png";

  var platformImage = new Image();
  platformImage.src = "images/brick.png";

  var battery1Image = new Image();
  battery1Image.src = "images/battery1.png";

  var battery2Image = new Image();
  battery2Image.src = "images/battery2.png";

  var door1Image = new Image();
  door1Image.src = "images/door1.png";

  var door2Image = new Image();
  door2Image.src = "images/door2.png";

  var doorOpenImage = new Image();
  doorOpenImage.src = "images/opendoor.png";

  var spikeImage = new Image();
  spikeImage.src = "images/spike.png";

  var platforms = [];
  var spikes = [];
  var entities = [];
  var batteries = [];

  for(i in level1.platforms) {
    var p = level1.platforms[i];
    var newP = new Platform(p[0], p[1], p[2], p[3], platformImage);
    platforms.push(newP);
    entities.push(newP);
  }

  for(i in level1.spikes) {
    var s = level1.spikes[i];
    var newS = new Spike(s[0], s[1], s[2], s[3], spikeImage);
    spikes.push(newS);
    entities.push(newS);
  }

  for(i in level1.batteries) {
    var b = level1.batteries[i];
    var newB = new Battery(b[0], b[1], battery1Image, battery2Image);
    batteries.push(newB);
    entities.push(newB);
  }

  var entrance = new Door(level1.entrance[0], level1.entrance[1], door1Image, door2Image, doorOpenImage);
  entrance.open();

  var exit = new Door(level1.exit[0], level1.exit[1], door1Image, door2Image, doorOpenImage);
  entities.push(exit);

  var player = new Player(level1.entrance[0], level1.entrance[1], playerImage, jumpImage);
  
  var collison = new CollisionManager(player, entities);

  var spike = new Spike(0, -200, 800, 200, spikeImage);

  var previousTs = -1;

  function render() {
    var nts = Date.now();
    var dt = 0
    if(previousTs > -1) {
      dt = nts - previousTs;

      var thisFrameFPS = 1000 / (dt);
      fps += (thisFrameFPS - fps) / 50;
      $fps.text(""+fps);
    }
    previousTs = nts;

    // if(player.fuel > 0) {
      player.update(dt, keys);
      collison.update();
      player.applyUpdate();
    // }

    canvas.width = canvas.width;
    context.fillStyle="#202020";
    context.fillRect(0,0,canvas.width,canvas.height);

    var translationX = Math.round(player.x);
    var translationY = Math.round(player.y - 50);

    context.translate(Math.round(canvas.width/2),Math.round(canvas.height/2));


    var backZoom = zoom / 2;
    context.scale(backZoom, backZoom);

    context.translate(-translationX,-translationY);

    if(backImage.width > 0) {
      var initialY = player.y-((canvas.height / 2) / backZoom)-backImage.height;
      var roundedY = Math.floor(initialY / backImage.height)*backImage.height;

      var initialX = player.x-((canvas.width / 2) / backZoom)-backImage.width;
      var roundedX = Math.floor(initialX / backImage.width)*backImage.width;
      for(var backX = roundedX; backX < roundedX + (canvas.width/backZoom)+(2 * backImage.width); backX += backImage.width) {
        var initY = roundedY;
        if((backX / backImage.width) % 2 == 0) {
          initY += (backImage.height / 2);
        }
        for(var backY = initY; backY < roundedY + (canvas.height/backZoom)+(2 * backImage.height); backY += backImage.height) {
          context.drawImage(backImage, backX, backY);
        }
      }
    }

    context.translate(translationX,translationY);
    context.scale(1/backZoom, 1/backZoom);

    context.scale(zoom, zoom);

    context.translate(-translationX,-translationY);


    entrance.render(context);
    exit.render(context);

    for(i in spikes) {
      spikes[i].render(context);
    }

    for(i in platforms) {
      platforms[i].render(context);
    }

    for(i in batteries) {
      batteries[i].render(context);
    }

    player.render(context);
    

    requestAnimFrame(render);
  }

  requestAnimFrame(render);

});
    </script>
  </body>
</html>
     
